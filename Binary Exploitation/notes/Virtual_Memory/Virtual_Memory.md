# Virtual Memory

The program that runs on your CPU does not access the actual physical memory present on the hardware. The Operating system creates an illusion of a virtual memory and a memory management unit or (MMU) automatically translates virtual addresses to physical addresses. As a result, we are able to access more memory than is actually present on our hardware. 

Virtual memory is not the same as RAM and the size of virtual memory depends on the system architecture. For a 64 bit machine, it is typically 2^64 bytes. In theory, the highest memory address possible is 0xffffffffffffffff (1.8446744e+19), and the lowest is 0x0

in order to see the layout of the memory that your program is using, go to ```/proc/[pid]/maps```

This will look something like this : 

```
55aed8fef000-55aed8ff0000 r--p 00000000 103:06 2366319                   /home/shogo/master/sec/CTFs/Reverse Engineering/notes/a.out
55aed8ff0000-55aed8ff1000 r-xp 00001000 103:06 2366319                   /home/shogo/master/sec/CTFs/Reverse Engineering/notes/a.out
55aed8ff1000-55aed8ff2000 r--p 00002000 103:06 2366319                   /home/shogo/master/sec/CTFs/Reverse Engineering/notes/a.out
55aed8ff2000-55aed8ff3000 r--p 00002000 103:06 2366319                   /home/shogo/master/sec/CTFs/Reverse Engineering/notes/a.out
55aed8ff3000-55aed8ff4000 rw-p 00003000 103:06 2366319                   /home/shogo/master/sec/CTFs/Reverse Engineering/notes/a.out
55aed9212000-55aed9233000 rw-p 00000000 00:00 0                          [heap]
7f0e14e00000-7f0e14e28000 r--p 00000000 103:06 14551392                  /usr/lib/x86_64-linux-gnu/libc.so.6
7f0e14e28000-7f0e14fbd000 r-xp 00028000 103:06 14551392                  /usr/lib/x86_64-linux-gnu/libc.so.6
7f0e14fbd000-7f0e15015000 r--p 001bd000 103:06 14551392                  /usr/lib/x86_64-linux-gnu/libc.so.6
7f0e15015000-7f0e15019000 r--p 00214000 103:06 14551392                  /usr/lib/x86_64-linux-gnu/libc.so.6
7f0e15019000-7f0e1501b000 rw-p 00218000 103:06 14551392                  /usr/lib/x86_64-linux-gnu/libc.so.6
7f0e1501b000-7f0e15028000 rw-p 00000000 00:00 0 
7f0e151ae000-7f0e151b1000 rw-p 00000000 00:00 0 
7f0e151d5000-7f0e151d7000 rw-p 00000000 00:00 0 
7f0e151d7000-7f0e151d9000 r--p 00000000 103:06 14551389                  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f0e151d9000-7f0e15203000 r-xp 00002000 103:06 14551389                  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f0e15203000-7f0e1520e000 r--p 0002c000 103:06 14551389                  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f0e1520f000-7f0e15211000 r--p 00037000 103:06 14551389                  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7f0e15211000-7f0e15213000 rw-p 00039000 103:06 14551389                  /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffe7138f000-7ffe713b1000 rw-p 00000000 00:00 0                          [stack]
7ffe713e1000-7ffe713e5000 r--p 00000000 00:00 0                          [vvar]
7ffe713e5000-7ffe713e7000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
```

So we get where exactly our heap and stack are stored in the memory. 

and ```/proc/[pid]/mem``` gives us access to the actual memory that our program is using. So we can actually play with the virtual memory of our running program and even change it. 

Now let's talk about argv and env arrays in our program. 

If you try to print the actual addresses of stack , heap , argv array and the env array, you will get the following : 

```
Address of a: 0x7ffd1af89e88
Allocated space in the heap: 0x5593ad4376b0
Address of function main: 0x5593ab83f1c9
First bytes of the main function:
        f3 0f 1e fa 55 48 89 e5 48 83 ec 40 89 7d dc 
Address of the array of arguments: 0x7ffd1af89fb8
Addresses of the arguments:
        [./a.out]:0x7ffd1af8bd06 [Shogo]:0x7ffd1af8bd0e [learning]:0x7ffd1af8bd14 [VM!]:0x7ffd1af8bd1d 
Address of the array of environment variables: 0x7ffd1af89fe0
Address of the first environment variable: 0x7ffd1af8bd21
```

Now, about this, the argv contains 5 arguments. the 4 cmd line arguments ```[a.out,Shogo,learning,VM!]``` and the final null argument or the line terminating argument. On a 64 bit machine, a pointer is 8 bytes in size. that translates to 8*5 = 40 or 0x28 memory space. 

Interestingly, ```0x7ffd1af89fb8 + 0x28 = 0x7ffd1af89fe0```

This proves that in our VM , the argv and env arrays are adjacent to each other. 

but the start of the cmd arguments is not right after the env array. 

The stack grows downwards in the VM and the heap grows upwards

Also a careful look at the cmd line args , argv array , env variables , env arrays will reveal that actually all these lie in the memory region of the stack only. 

If there is no malloc in your program , then no heap would be used in the memory map of your program. Further as malloc is manipulating the heap , there must be some system call underlying malloc. In order to know which syscall is actually being used, we can wrap it around with a write syscall and call strace. 

Now, from strace we focus on the following lines : 

```
brk(NULL)                               = 0x5645260d6000
brk(0x5645260f7000)                     = 0x5645260f7000
```

from man brk, we can see that brk and sbrk are syscalls to allocate and deallocate memory. More precisely, 

```
DESCRIPTION
       brk() and sbrk() change the location of the program  break,  which  defines
       the end of the process's data segment (i.e., the program break is the first
       location after the end of the uninitialized data segment).  Increasing  the
       program  break has the effect of allocating memory to the process; decreas‐
       ing the break deallocates memory.

       brk() sets the end of the data segment to the value specified by addr, when
       that  value  is  reasonable,  the system has enough memory, and the process
       does not exceed its maximum data size (see setrlimit(2)).

       sbrk() increments the program's data space  by  increment  bytes.   Calling
       sbrk()  with  an increment of 0 can be used to find the current location of
       the program break.
```

The first brk call returns the pointer to the current program break and the second call actually increases the program break. 

Malloc essentially allocates more memory on the heap than asked for, this essentially makes further calls to malloc more efficient as more syscalls are now not required. 

Whenever we call malloc , the first 10 bytes are reserved to store the size of the chunk. when the previous chunk has been free’d, the malloc chunk’s first 8 bytes contain the size of the previous unallocated chunk. the next 2 bytes give away the size of the new malloc'd chunk. 